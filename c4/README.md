平坦模式：将所有地址拉通，即所有地址一个寄存器就可表示，不需要“基址+偏移”表示

实模式：没有保护，没有权限之分，操作系统和用户程序一样平等。



实模式下内存寻址：

基地址只能是bx,bp

变址寄存器只能是si,di

bx默认的段寄存器是ds

bp默认的段寄存器是ss



`基址寄存器作指针，变址寄存器作索引`



形如  mov ax,[bx+si]常用来表示数组操作

bx是指针，si为索引

## 4.2.3保护模式之运行模式反转

需要用汇编语言显式地转换CPU模式

#### bits指令

指定范围

[bits 16]编译16位的机器码(默认)

[bits 32]编译32位的机器码

其使用需要显式地指出在那一个模式下(编译器并不能猜出)



bits指令使用

```assembly
[bits 16]
mov ax, 0x1234
mov dx, 0x1234

[bits 32]
mov eax, 0x1234
mov edx, 0x1234
```



操作数反转前缀(0x66),寻址方式反转前缀(0x67)

其只表现在机器码，

```assembly
#操作数反转
[bits 16]
mov ax, 0x1234    #编译成16位
mov eax, 0x1234	 #反转，成32位

[bits 32]
mov ax, 0x1234	#反转，编译成16位
mov edx, 0x1234	#编译成32位
```



```asm
#寻址方式反转
[bits16]
mov word [bx] 0x1234
mov word [eax] 0x1234 #寻址方式反转，16位地址，变32位
mov dword [eax],0x1234 #寻址方式反转，且操作数反转，都16变32

[bits32]
mov dword [eax] 0x1234
mov word [eax] 0x1234 #操作数反转
mov dword [bx],0x1234 #寻址方式反转
```



#### 打开保护模式条件

1. 打开A20
2. 加载gdt
3. 将cr0的pe位置1

以上三个步骤没有固定顺序，也可以不连续。



## 4.2.4保护模式之指令拓展



# 4.3全局描述符

保护模式下，需要把段提前定义好才能使用

描述符的第0个都是不能用的

在段描述符格式中，段基址和段界限都不是连续存放的

> cpu眼中，凡是硬件运行所需要的东西都称之为系统，凡是软件需要的东西都称为数据



一致性代码段

​	操作系统拿出来被共享的代码段，可以被低特权级的用户直接访问调用的代码，但不改变其特权级。



GDT 全局描述符，所有程序可使用

LDT 局部描述符，为在硬件一级原生支持多任务。（按设想，一个任务对应一个LDT,但现代操作系统好像很少用，且要访问LDT,需先访问GDT）



段描述符格式

8字节大小

![](https://i.imgur.com/LITCnW5.png)

段界限：

- 段边界的拓展最值，最大或最小拓展多少。拓展方向只有上下（往高地址或低地址）。对于数据段和代码段是向上的（即高地址）

- 段界限表示的是单位量，单位是`BYTE`或是`4KB`,由描述符中的G位表示，段的最终边界是`界限值*单位`

  故段的大小要么是$2^{20} \centerdot 1KB=1M$，要么是$2^{20} \centerdot 4KB=4G$
  
- 段界限只是一个范围，实际的段边界（==描述符中段界限+1== ）* （==段界限的颗粒度大小：4K或1==） -1

- 为了兼容，段界限储存的位置并不在同一地方



各特殊位意义：

- S位代表是否系统段(0是系统段，1不是系统段)

- P位代表是否存在(1存在，0不存在)

- AVL(AVaiLable)位，是否可用(对于用户而言，操作系统随意，算是一种硬件冗余吧)

- L(Large?)位，表示位数(1表示64位，0表示32位)

- D/B位，是为兼容80286的产物。对于代码段来说此位是D,若为0表明指令中有效地址和操作数是16位，用`IP`寄存器;如果是1,表明指令中有效地址及操作数是32位，用`EIP`寄存器。
- G(Granularity)位,表明颗粒度，若为0是`1BYTE`。若为1是`4KB`



TYPE字段

- 共4位,在不同段内(系统段和非系统段)有不同的作用

  ![](https://i.imgur.com/ctQOFPm.png)

  暂时看非系统段：

  - A(Accessed)位，表示是否最近被访问(新段中其为0)，关于内存的换入换出算法时会比较重要
  - C(Conforming)位，是否为一致性代码段。关于一致性代码段，该代码段中的指令执行多次，其结果不变。通常是操作系统的一些共享函数，可以被多个进程执行。其虽在共享库，但用户进程在执行时特权级通常没有改变，仍是用户级。
  - R(readable)位，是否可读
  - X(EXecutable)位，是否可执行
  - E(Extend)位，拓展方向。0向上(高地址)拓展，1向下(低地址)拓展
  - W(Writable)位，是否可写



GDTR寄存器

即GDT Register，储存GDT的内存地址及大小，其是一48位的寄存器。

![](https://i.imgur.com/FIJpG6K.png)

进入保护模式需要有GDT

lgdt的指令格式是：lgdt`48位内存数据`

前16位是是以字节为单位的界限,共$2^{16}=65536$字节，每个描述符8字节，所以GDT最多可容纳$65536/8=8192$个，即可以容纳8192个段或门(暂时理解位系统调用，不知可不可以)



关于段的选择子

段寄存器CS,DS,ES,FS,GS,SS在实模式中存储的是段基址，即内存的起始地址。在保护模式下，段基址已经在段描述符存入，就没有再往段寄存器中存，此时段寄存器中存入的就是选择子(Selector)。其'基本上'是个索引值。

由于段寄存器是16位的(不要忘记，即使是保护模式下，段寄存器依然是16位)，所选择子也是16位。

低2位(0~1位)，储存RPL(Request Privilege Level)。其实写死在描述符中的静态数据哦

第2位是TI(Table Indicator)位，指示是GDT还是LDT(0表示GDT,1表示LDT)

第3~15位表示描述符的索引值($2^{13}=8192$，刚好等于每，描述符个数，相当于数组下标)

==选择子除了去顶描述符位置，还有特权级和界限等安全性考虑==

这里，段描述符的第`0`个不可访问，也用作==警报==机制

lldt的操作形式和lgdt差不多，不同的是LDT中的第0个段描述符可用



A20地址线

在16位的8086CPU中超过`1M`的地址寻址，会地址回绕(wrap-around)

在后面的CPU中，即使地址总线超过20,我们也希望其能够兼容8086。

例如80286CPU,但其有24根地址总线，能寻址$2^{24}=16M$的内存空间。

但实模式下也只使用到20根地址总线。

于是，用第21根地址先作为`A20Gate`

- 如果`A20Gate`打开，能访问完成的所有地址空间
- 如果`A20Gate`关闭，多于`1M`的地址空间将`地址回绕`

打开方法：将0x92端口的第一位置1



保护模式的开关，CR0寄存器的PE位

![](https://i.imgur.com/a1RRy4D.png)

CR0的第0位，即PE(Protection Enable)位，保护模式的开关

![](https://i.imgur.com/aqb1O5x.png)

#### CR0寄存器的修改可以直接用`mov`指令





处理器微架构

流水线机制

![](https://i.imgur.com/nNPi60l.png)

如果当前指令与下一条指令物理相邻且按一定顺序执行，那么按照流水线正常工作。

如果出现无条件转移指令`jmp`时，之前送入流水线的指令已经没用了，CPU会强制清空流水线

相关技术：

- 乱序执行
- 分支预测



在保护模式内存段的保护里会有一些检查

比如：

- 选择子的检查。无论选择子多少，要求最终索引的地址不能超出段描述符表
- 在各个内存段中检查方向及大小
