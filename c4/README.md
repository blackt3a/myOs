平坦模式：将所有地址拉通，即所有地址一个寄存器就可表示，不需要“基址+偏移”表示

实模式：没有保护，没有权限之分，操作系统和用户程序一样平等。



实模式下内存寻址：

基地址只能是bx,bp

变址寄存器只能是si,di

bx默认的段寄存器是ds

bp默认的段寄存器是ss



`基址寄存器作指针，变址寄存器作索引`



形如  mov ax,[bx+si]常用来表示数组操作

bx是指针，si为索引

## 4.2.3保护模式之运行模式反转

需要用汇编语言显式地转换CPU模式

#### bits指令

指定范围

[bits 16]编译16位的机器码(默认)

[bits 32]编译32位的机器码

其使用需要显式地指出在那一个模式下(编译器并不能猜出)



bits指令使用

```assembly
[bits 16]
mov ax, 0x1234
mov dx, 0x1234

[bits 32]
mov eax, 0x1234
mov edx, 0x1234
```



操作数反转前缀(0x66),寻址方式反转前缀(0x67)

其只表现在机器码，

```assembly
#操作数反转
[bits 16]
mov ax, 0x1234    #编译成16位
mov eax, 0x1234	 #反转，成32位

[bits 32]
mov ax, 0x1234	#反转，编译成16位
mov edx, 0x1234	#编译成32位
```



```asm
#寻址方式反转
[bits16]
mov word [bx] 0x1234
mov word [eax] 0x1234 #寻址方式反转，16位地址，变32位
mov dword [eax],0x1234 #寻址方式反转，且操作数反转，都16变32

[bits32]
mov dword [eax] 0x1234
mov word [eax] 0x1234 #操作数反转
mov dword [bx],0x1234 #寻址方式反转
```



#### 打开保护模式条件

1. 打开A20
2. 加载gdt
3. 将cr0的pe位置1

以上三个步骤没有固定顺序，也可以不连续。



## 4.2.4保护模式之指令拓展



# 4.3全局描述符

保护模式下，需要把段提前定义好才能使用

描述符的第0个都是不能用的

在段描述符格式中，段基址和段界限都不是连续存放的

> cpu眼中，凡是硬件运行所需要的东西都称之为系统，凡是软件需要的东西都称为数据



一致性代码段

​	操作系统拿出来被共享的代码段，可以被低特权级的用户直接访问调用的代码，但不改变其特权级。



GDT 全局描述符，所有程序可使用

LDT 局部描述符，为在硬件一级原生支持多任务。（按设想，一个任务对应一个LDT,但现代操作系统好像很少用，且要访问LDT,需先访问GDT）
