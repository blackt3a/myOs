在Linux获取内存的方法不止一种，一种不行就换另一种

1. EAX=0xE820    便历主机全部内存

  其返回的地址范围描述符(Address Range Descriptor Structure, ARDS) 如下：(注意，此字段大小为20字节，表中基地址和长度都分为低32位和高32位)

  ![](https://i.imgur.com/P4P4T4m.png)

  ![](https://i.imgur.com/h8XELRv.png)

  BIOS按类型返回内存信息，因为其内存可能是：

  - 系统的ROM
  - ROM用到了这部分内存
  - 设备内存映射到了这部分内存
  - 由于某些原因，这段内存不适合标准设备使用

  由于我们在32位的工作环境下，所以在`ARDS`结构属性中，我们只用到32位属性。`BaseAddrLow+LengthLow`是一片内存区域上限，单位是字节。除非安装的物理内存极小，否则不会出现较大的内存区域不可用

  调用方法：

  ![](https://i.imgur.com/CypG7HS.png)

  ![](https://i.imgur.com/jAoc4wy.png)

  表中的ECX寄存器和ES：DI寄存器，是典型的“值-结果”型参数，即调用方提供两个变量作为被调用函数的参数，一个是缓冲区指针，一个是缓冲区大小。被调用函数在缓冲区中写入数据后，将实际所写入的字节数记录到缓冲区大小变量中。

  中断步骤如下：

  - 填写“调用前输入”中的寄存器
  - 执行中断调用`int 0x15`
  - 在CF位为0的情况下，“返回后输出”中对应的寄存器便会有对应的结果

  

2. AX  =0xE801    分别检测第`15MB`和`16MB～4GB`的内存，最大支持`4GB`

此法简单，但功能也不强大，最多只识别`4GB`内存。特别的是，此法检测的内存是分别存放到两组寄存器中的。低于`15MB`的内存以`1KB`为单位来记录，单位数量在AX和CX寄存器中记录(其中，AX和CX的值是一样的)，所以在`15MB`空间以下的实际内存容量=AX*`1024`。AX,CX最大值为`0x3c00`(即`0x3c00*1024=15MB`

`16MB~4GB`是以`64KB`为单位大小来记录的，单位数量在寄存器BX和DX中记录(其中BX和DX的值是一样的)，所以`16MB`以上的空间的内存实际大小=`BX*64*1024`，BX和DX的最大值，其实无所谓，反正只支持`4GB`最大。

![](https://i.imgur.com/oPsXPzt.png)

​		关于为什么`0xE801`调用显得有点奇怪，也是因为历史遗留的兼容问题。在80286时期(其寻址大小为`16MB`，此时有些ISA设备需要用到`15MB`以上的内存作为缓冲区，此缓冲区`1MB`大小，硬件系统将其保留下来，操作系统不可使用，形成内存空洞(memory hole)。此兼容一直持续到现在。使用`0xE801`也是因为支持拓展ISA设备的支持。

实际内存大于`16MB`时，能检测出内存空洞。但是实际内存小于`16MB`时，检测出的内存仍然会小一些，此时实际结果比检测结果多`1MB`（并没有少，可用，只是显示得少了）

`0xE801`的调用步骤：

- 将AX寄存器写入`0xE801`
- 执行中断调用int 0x15
- 在CF位为0的情况下，“返回后输出”中对应的寄存器便会有对应的结果





3. AH=0x88          最多检测`64MB`内存，实际内存超过此容量也按照`64MB`返回

此方法使用最简单，功能也最简单，最多检测`64MB`的内存

![](https://i.imgur.com/oPsXPzt.png)

即便内存容量大于`64MB`也只会显示`63MB`的内存，显示`1MB`之上的内存，不包括这`1MB`。

中断调用步骤：

- 将AX寄存器写入0x88
- 执行中断用int 0x15
- 在CF为0的情况下，“返回后输出”中对应的寄存器便会有对应的结果



分页机制

关于换入换出



页表

![](https://i.imgur.com/Xy7ema7.png)

![](https://i.imgur.com/IkaejGY.png)

经转换，物理地址变为虚拟地址



线性地址空间，指程序内部内存空间(不同任务可能有相同线性空间,却不会影响)

虚拟地址空间，指对物理地址的映射

物理地址空间，指内存条上的线性空间



一个页表项4字节大小

![](https://i.imgur.com/ZYMweJe.png)



关于一级页表

线性地址的高`20`位在页表中，索引页表项，用线性地址中的低`12`位与页表项中的物理地址相加，所求和就是线性地址最终的物理地址

![](https://i.imgur.com/ZDyoKhR.png)



关于二级页表

二级页表的理由：

- 一级页表中最多可以容纳$2^{20}=1M$个页表项，每个页表项4KB大小，若页表全满，其大小为4MB.
- 一级页表中所有页表都需要提前建好，因为操作系统需要使用4GB虚拟地址的高1GB,用户进程要占用低3GB
- 每一个进程都有自己的页表，当进程很多时，页表所占空间也多

总结：不把页表一次性建好，需要时动态创建页表项



具体实现：

​	所有页表都是标准页(即4KB大小)，所以4GB最多1M个标准页。

​	二级页表将`1M`个标准页平均放置在`1K`个页表中(如果采用一级页表，这1M页表项都会在同一页表中)

​	每一个页表包含`1k`个页表项，每个页表项`4KB`大小，刚好塞满一个标准页。

​	共`1K`个页表，最终大小也会`4MB`大小，但更灵活

![](https://i.imgur.com/wuBNv9y.png)

​	页目录一共`1024`个页表，每个页表`1024`个也目录项。内存在物理内存中离散分布，不分类型，毫无规律。



二级页表中定位物理页：

- 虚拟地址的高`10`位在页目录中定位==页表==(页目录项PDE)
- 虚拟地址的中`10`位在页表中定位具体的==物理页==(页表项PTE)
- 虚拟地址中余下`12`位定位具体的页内偏移

因为以上数据都是`4KB`大小，所以在给出索引后，具体寻址需要$\times 4$

这种自动化较强的工作可交由硬件(页部件)自动完成。

以`mov ax, [0x1234567]`举例：

![](https://i.imgur.com/zm0bHJU.png)



每一个任务都有自己的页表，每一个任务都以为自己独占内存空间。



前面说过，也目录项和页表项也都是`4BYTE大小`，但是我们在索引时(索引最大时，也只需要$2^{20}=1K$个，并不需要`32位`,多的`12`位可以储存其它信息。

![](https://i.imgur.com/jg4NUio.png)

P(Present)，存在位，若为1表示该页存在于物理页，若为0表示不再物理页，操作系统的页式虚拟内存管理便是通过P位和相应的pagefault异常实现

RW(Read/Write)，读写位，若为1表示可读可写，若为0表示可读不可写

US(User/Supervisor)，普通用户/超级用户位。若为1表示User级，任意级别可访问。若为0,表示Supervisor级，只允许0,1,2访问，特权级3不可访问。

PWT(Page-level Write-Through),页级通写位(页级写透位)，若为1表示采用通写方式，表示该位不仅仅是普通内存，还是高速缓存。此项和高速缓存有关，“通写”是高速缓存的一种工作方式，本位用来间接决定是否用此方式改善该页的访问效率。此处暂时为0.

PCD(Page-level Cache Disable)，页级高速缓存禁止位，若为1表示该页启用高速缓存，0表示禁止该页缓存。此处暂时置0

A(Accessed)，访问位。若为1表示该页已被CPU访问过，所以该位由CPU设置.内存置换算法可用。

D(Dirty)，意为脏页。当一个CPU对页进行写操作时，就会设置对应的D位为1。此项只针对==页表项==，不会修改页目录项中的D位。

PAT(Page Attribute Table)，意为页属性表位，能够在页一级的粒度上设置内存属性。较为复杂，此处暂时置0.

G(Global)，意为全局位。为了提高获取物理页的速度，将虚拟地址与物理页转换结果储存在TLB(Translation Lookaside Buffer)。该位用来指定该页是否为全局页。1表示全局页，0表示不是全局页。若是全局页，该位将在高速缓存TLB中一直保存，给出虚拟地址直接就出物理地址，无需转换。

顺便说，清空TLB有两种方式：

- 用invlpg指令单独对虚拟地址条目清理
- 重新加载`cr3`寄存器，直接清空TLB

AVL(Available)，表示可用。相对用户程序而言，操作系统可用该位，CPU不会理会。



启动分页机制，需做好三件事：

- 准备好==页目录表==和==页表==
- 将页表地址写入寄存器`cr3`
- 寄存器`cr0`的PG位置1



页表描述符也会时内存中的一个数据结构，处理器有专门的寄存器储存它，即`cr3`寄存器

因为页目录表所在的地址要求在一个自然页内，即页的起始地址是`4KB`的整数倍，低`12`位全是0。

所以`cr3`的第`31～12`(高20)位写入物理地址。相应的，低12位可以储存一些其他信息(事实上，除`PCD`和`PWT`其他位也没啥用)。

关于cr3(Page Directory Base Register,PDBR)寄存器



![](https://i.imgur.com/iqTNj6h.png)



打开分页机制需将`cr0`寄存器的PG位(第1位)置1。顺便说一下，第0位是PE位，保护模式开关。



在Linux中，用户进程`4GB`虚拟地址空间的高`3GB`以上的部分划给操作系统，`0～3GB`是用户进程自己的虚拟空间(但不一定都有映射)。为了实现共享操作系统，也就是让所有进程的虚拟地址`3GB～4GB`指向==同一片物理页地址==。



加入我们在内存中，让==所有页表==紧挨==页目录表==，且将页目录表存放在`0x100000`处，那么第一个页表位置是`0x101000`

![](https://i.imgur.com/KzryQtb.png)

